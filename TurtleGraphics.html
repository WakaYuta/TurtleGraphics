<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <title>Turtle Graphics</title>
  <link type="text/css" rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/cupertino/jquery-ui.min.css" />
  <link rel="stylesheet" href="static/css/TurtleGraphics.css" />
  <link rel="stylesheet" href="static/css/introjs.min.css" />
</head>

<body>
  <div id="page" style="width: 100%; height: 100%">
    <div id="main">
      <div id="canvas_area">
        <div id="taskname"></div>
        <div id="canvas_wrapper">
          <div id="answer-mark" class="mark-icon">〇</div>
          <canvas id="mainCanvas" width="700" height="700"></canvas>
          <canvas id="gridCanvas" width="700" height="700"></canvas>
          <img id="overlayImage" src="" />
        </div>
        <div id="field">
          <div class="color-picker-container">
            <label class="color-picker-label" for="colorPicker">ペンの色</label>
            <input class="color-picker" type="color" id="colorPicker" value="#000000" />
          </div>
          <div id="generate_button_container"></div>
          <button class="btn" type="button" id="gridButton" onclick="grid()">
            グリッド
          </button>
          <button class="btn" type="button" onclick="clearbtn()">
            クリア
          </button>
          <button id="btn_check" class="btn btn_check" type="button" onclick="check()">
            チェック
          </button>
        </div>
      </div>

      <div id="center_area">
        <div class="top-buttons">
          <button id="btn_start" class="btn btn_action" type="button" onclick="start()">
            スタート
          </button>
          <button id="btn_stop" class="btn btn_action btn_stop_style" type="button" onclick="stopExecution()">
            ストップ
          </button>
        </div>
        <div id="code_area">
          <div id="code_area1" class="blocksnap_area"></div>
          <div id="code_area2" class="blocksnap_area"></div>
          <div id="code_area3" class="blocksnap_area"></div>
          <div id="code_area4" class="blocksnap_area"></div>
          <div id="code_area5" class="blocksnap_area"></div>
          <div id="code_area6" class="blocksnap_area"></div>
          <div id="code_area7" class="blocksnap_area"></div>
          <div id="code_area8" class="blocksnap_area"></div>
          <div id="code_area9" class="blocksnap_area"></div>
        </div>
      </div>

      <div id="right_area">
        <div class="top-buttons">
          <button id="btn_menu" class="btn btn_action" type="button" onclick="return_menu()">
            メニュー
          </button>
          <button id="btn_next" class="btn btn_action" type="button" onclick="next_stage()">
            次へ
          </button>
        </div>
        <div id="block_area"></div>
      </div>

    </div>
  </div>

  <img src="static/assets/turtle.png" id="turtle" style="position: absolute; top: 450px; left: 450px" />
  <script src="static/js/intro.min.js"></script>
  <script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
  <script type="text/javascript" src="http://code.jquery.com/ui/1.10.3/jquery-ui.min.js"></script>
  <script type="text/javascript">
    var startx = 350; //初期位置
    var starty = 350; //初期位置
    let currentX = startx;
    let currentY = starty;
    var x = (y = a = 0);
    let turtle_speed = 1;
    const codeAreaSize = 9;
    let totalBlocks = 0;
    let isRunning = false;
    let animationFrameId = null; // 「歩く」アニメーションの管理番号
    let timeoutId = null;        // 「回転」の待ち時間の管理番号

    const maincanvas = document.querySelector("#mainCanvas");
    const gridcanvas = document.querySelector("#gridCanvas");
    const mainCtx = maincanvas.getContext("2d", { willReadFrequently: true });
    const gridCtx = gridcanvas.getContext("2d");
    const colorPicker = document.getElementById("colorPicker");
    let lineColor = "rgb(0, 0, 0)";

    mainCtx.fillStyle = "rgb(255, 255, 255)"; // キャンバスの背景色（内側の白色） 
    mainCtx.fillRect(0, 0, maincanvas.width, maincanvas.height);

    window.addEventListener("DOMContentLoaded", function () {
      const urlParams = new URLSearchParams(window.location.search);
      const stage = urlParams.get("stage") || "1";

      fetch('stage_data.json')
        .then(response => {
          if (!response.ok) {
            throw new Error("stage_data.jsonの読み込みに失敗しました。");
          }
          return response.json();
        })
        .then(stageData => {
          const stageInfo = stageData[stage];
          if (!stageInfo) {
            alert('無効なステージです。メニューに戻ります。');
            window.location.href = 'landing.html';
            return;
          }

          document.getElementById('taskname').textContent = stageInfo.title;
          document.getElementById('overlayImage').src = `static/assets/${stageInfo.image}`;

          ////////////////////////////
          //jsonに基づいてブロック生成//
          ////////////////////////////
          let blocks_html = '';
          let generate_html = '';
          let block_id = 1;
          let number_id = 1;

          const blockCounts = stageInfo.blocks;
          totalBlocks = Object.values(blockCounts).reduce((sum, count) => sum + count, 0);

          if (stage === "4") {
            generate_html += `<img src="static/assets/Obstacle.png" id="blockGenerateButton" class="btn_generate" onclick="block_Generate()">`;
          }

          for (let i = 0; i < (blockCounts.block1 || 0); i++) {
            if (stage === "4") {
              blocks_html += `<div class="block" id="block${block_id}" data-type="fd"><p class="center"><input type="number" id="number${number_id}" class="block_numbox" value="999" min="0" max="999" readonly />歩進む<br /></p></div>`;
            } else {
              blocks_html += `<div class="block" id="block${block_id}" data-type="fd"><p class="center"><input type="number" id="number${number_id}" class="block_numbox" min="0" max="999" />歩進む<br /></p></div>`;
            }
            number_id++;
            block_id++;
          }
          for (let i = 0; i < (blockCounts.block2 || 0); i++) {
            blocks_html += `<div class="block" id="block${block_id}" data-type="rt"><p class="center"><input type="number" id="number${number_id}" class="block_numbox" min="0" max="999" />度右に曲がる<br /></p></div>`;
            block_id++;
            number_id++;
          }
          for (let i = 0; i < (blockCounts.block3 || 0); i++) {
            blocks_html += `<div class="block" id="block${block_id}" data-type="lt"><p class="center"><input type="number" id="number${number_id}" class="block_numbox" min="0" max="999" />度左に曲がる<br /></p></div>`;
            block_id++;
            number_id++;
          }
          for (let i = 0; i < (blockCounts.block4 || 0); i++) {
            blocks_html += `<div class="block" id="block${block_id}" data-type="for1"><p class="center"><input type="number" id="number${number_id}" class="block_numbox" min="0" max="999" />回繰り返す<br /></p></div>`;
            block_id++;
            number_id++;
          }
          for (let i = 0; i < (blockCounts.block5 || 0); i++) {
            blocks_html += `<div class="block" id="block${block_id}" data-type="for2"><p class="center">ここまで繰りかえす<br /></p></div>`;
            block_id++;
          }
          for (let i = 0; i < (blockCounts.block6 || 0); i++) {
            blocks_html += `<div class="block" id="block${block_id}" data-type="if1"><p class="center">壁にぶつかったら<br /></p></div>`;
            block_id++;
          }
          for (let i = 0; i < (blockCounts.block7 || 0); i++) {
            blocks_html += `<div class="block" id="block${block_id}" data-type="if2"><p class="center">ここまでIF<br /></p></div>`;
            block_id++;
          }

          document.getElementById('block_area').innerHTML = blocks_html;
          document.getElementById('generate_button_container').innerHTML = generate_html;

          const blockArea = document.getElementById('block_area');
          const initialHeight = blockArea.offsetHeight; // 最初の高さを記憶
          blockArea.style.height = `${initialHeight}px`; // 高さを固定する

          $(".block").draggable({
            start: function () { $(this).addClass("block_drag").removeClass("block_snap"); },
            stop: function () { $(this).removeClass("block_drag"); },
          });
        })
        .catch(error => console.error('Error:', error));

      fetch(`static/json/tutorials_stage${stage}.json`)
        .then((res) => {
          if (!res.ok) {
            throw new Error("チュートリアルファイルの読み込みに失敗しました。");
          }
          return res.json();
        })
        .then((steps) => {
          intro.setOptions({
            showProgress: false,
            disableInteraction: true,
            exitOnEsc: false,
            exitOnOverlayClick: false,
            nextLabel: "次へ",
            prevLabel: "戻る",
            doneLabel: "完了",
            steps: steps,
          });
          intro.start();
        })
        .catch(error => console.error('Error:', error));
    });

    //////////////////
    ///グリッド描画////
    //////////////////
    const gridSize = 100;

    function drawGrid() {
      // 薄いグリッド線を描く
      gridCtx.strokeStyle = "rgb(230, 230, 230)";
      gridCtx.lineWidth = 1;

      for (let i = gridSize; i < Math.max(gridcanvas.width, gridcanvas.height); i += gridSize) {
        if (i < gridcanvas.width) {
          gridCtx.beginPath(); gridCtx.moveTo(i, 0); gridCtx.lineTo(i, gridcanvas.height); gridCtx.stroke();
        }
        if (i < gridcanvas.height) {
          gridCtx.beginPath(); gridCtx.moveTo(0, i); gridCtx.lineTo(gridcanvas.width, i); gridCtx.stroke();
        }
      }

      // 右下にL字型のスケールバーを描く
      const barLength = 100;

      // コーナーの位置を計算
      // 線の太さ分(1.5px)だけ内側にずらす
      const cornerX = (Math.floor(gridcanvas.width / gridSize) * gridSize) - 1.5;
      const cornerY = (Math.floor(gridcanvas.height / gridSize) * gridSize) - 1.5;

      // スタート位置
      const hStartX = cornerX - barLength; // 横棒の左端
      const vStartY = cornerY - barLength; // 縦棒の上端

      gridCtx.strokeStyle = "rgb(100, 100, 100)";
      gridCtx.lineWidth = 3; // 太線
      gridCtx.beginPath();

      // 横線（左から右下の角へ）
      gridCtx.moveTo(hStartX, cornerY);
      gridCtx.lineTo(cornerX, cornerY);

      // 縦線（上から右下の角へ）
      gridCtx.moveTo(cornerX, vStartY);
      gridCtx.lineTo(cornerX, cornerY);

      // 目盛り
      const tickSize = 6;

      // 横棒の左端の目盛り
      gridCtx.moveTo(hStartX, cornerY - tickSize);
      gridCtx.lineTo(hStartX, cornerY + tickSize);

      // 縦棒の上端の目盛り
      gridCtx.moveTo(cornerX - tickSize, vStartY);
      gridCtx.lineTo(cornerX + tickSize, vStartY);

      gridCtx.stroke();

      // 文字を描く
      gridCtx.fillStyle = "rgb(100, 100, 100)";
      gridCtx.font = "bold 14px sans-serif";

      // 横の「100歩」
      gridCtx.textAlign = "center";
      gridCtx.textBaseline = "bottom";
      gridCtx.fillText("100歩", hStartX + (barLength / 2), cornerY - 8);

      // 縦の「100歩」
      gridCtx.textAlign = "right";
      gridCtx.textBaseline = "middle";
      gridCtx.fillText("100歩", cornerX - 10, vStartY + (barLength / 2));
    }
    drawGrid();
    let flag = true;
    function grid() {
      if (flag) {
        gridCtx.clearRect(0, 0, gridcanvas.width, gridcanvas.height);
        flag = false;
      }
      else {
        drawGrid();
        flag = true;
      }
    }

    //////////////////
    //クリックイベント//
    //////////////////
    mainCtx.strokeStyle = lineColor;
    // イベントリスナーを追加して色の変更を検知する
    colorPicker.addEventListener("input", function () { lineColor = colorPicker.value; mainCtx.strokeStyle = lineColor; });
    maincanvas.addEventListener("click", (e) => {
      let rect = e.target.getBoundingClientRect();
      // ブラウザ上でのクリック位置を取得
      const viewX = e.clientX - rect.left, viewY = e.clientY - rect.top;
      // 表示サイズとキャンバスの実際のサイズ比率を計算
      const scaleWidth = maincanvas.clientWidth / maincanvas.width, scaleHeight = maincanvas.clientHeight / maincanvas.height;
      // ブラウザのクリック位置をキャンバス上の位置に変換
      currentX = Math.floor(viewX / scaleWidth);
      currentY = Math.floor(viewY / scaleHeight);
      const turtle = document.getElementById("turtle");
      // タートルの幅と高さを取得
      const turtleWidth = turtle.offsetWidth;
      const turtleHeight = turtle.offsetHeight;
      // カメのしっぽの位置をクリック位置に合わせるための調整
      turtle.style.position = "absolute";
      turtle.style.left = `${rect.left + window.pageXOffset + currentX - turtleWidth / 2}px`;
      turtle.style.top = `${rect.top + window.pageYOffset + currentY - turtleHeight}px`;
      //クリック時にカメの向きをリセット
      a = 0;
      turtle.style.transform = `rotate(${a}deg)`;
    });

    //////////////////
    ////障害物生成/////
    //////////////////
    const obstacles = [];
    let imageCounter = 0;

    function block_Generate() {
      const canvasWrapper = document.getElementById("canvas_wrapper");
      const img = document.createElement("img");
      img.src = "static/assets/Obstacle.png";
      img.classList.add("draggable");
      img.width = 50; img.height = 50;
      const cols = Math.floor(maincanvas.width / 50);
      const x = (imageCounter % cols) * 50;
      const y = Math.floor(imageCounter / cols) * 50;
      img.style.position = "absolute";
      img.style.left = `${maincanvas.offsetLeft + x}px`;
      img.style.top = `${maincanvas.offsetTop + y}px`;
      canvasWrapper.appendChild(img);
      imageCounter++;
      obstacles.push(img);
      $(img).draggable({ containment: "#canvas_wrapper" });
    }

    //////////////////
    //ドラッグ処理開始//
    //////////////////
    $(function () {
      $('body').on('mousedown', '.block', function () {
        $(this).draggable({
          start: function (event, ui) {
            $(this).addClass("block_drag");
            $(this).data('dropped_successfully', false);
          },
          stop: function (event, ui) {
            $(this).removeClass("block_drag");
            if (!$(this).data('dropped_successfully')) {
              $(this).appendTo('#block_area').removeClass('block_snap').css({ top: 0, left: 0 });
            }
            create_array();
          }
        });
      });

      $(".blocksnap_area").droppable({
        accept: ".block",
        hoverClass: "block_hover",
        drop: function (event, ui) {
          const droppedBlock = ui.draggable;

          droppedBlock.data('dropped_successfully', true);

          $(this).children('.block').appendTo('#block_area').removeClass('block_snap').css({ top: 0, left: 0 });

          droppedBlock.appendTo(this).addClass("block_snap").css({ top: 0, left: 0 });
        }
      });

      $("#block_area").droppable({
        accept: ".block",
        drop: function (event, ui) {
          ui.draggable.data('dropped_successfully', true);
          ui.draggable.appendTo(this).removeClass("block_snap").css({ top: 0, left: 0 });
        }
      });
    });

    //////////////////
    // 配列を作る ////
    //////////////////
    function create_array() {
      // 配列を一度リセット
      code_array = Array(codeAreaSize).fill(0).map(() => Array(2).fill(0));

      $('#code_area .blocksnap_area').each(function (index) {

        const blockElement = $(this).find('.block').get(0);

        if (blockElement) {
          code_array[index][0] = blockElement.dataset.type;
          code_array[index][1] = blockElement;
        }
      });

      console.log("配列=", code_array);
      document.dispatchEvent(new CustomEvent("codeArrayChanged"));
    }

    //////////////////
    ///// クリア //////
    //////////////////
    function clearbtn() {
      mainCtx.fillStyle = "rgb(255, 255, 255)";
      mainCtx.fillRect(0, 0, maincanvas.width, maincanvas.height);
    }
    function getObstacleBounds(obstacle) {
      const rect = obstacle.getBoundingClientRect();
      return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.bottom };
    }

    //////////////////
    ///// 前進 //////
    //////////////////
    function fd(step) {
      return new Promise((resolve) => {
        let rect = maincanvas.getBoundingClientRect();
        function fd_draw() {
          if (!isRunning) return; // 停止フラグ確認

          mainCtx.strokeStyle = colorPicker.value;
          if (step > 0) {
            const nextX = currentX + turtle_speed * Math.sin((a * Math.PI) / 180.0);
            const nextY = currentY - turtle_speed * Math.cos((a * Math.PI) / 180.0);
            // 境界チェック
            if (nextX <= 0 || nextX >= maincanvas.width || nextY <= 0 || nextY >= maincanvas.height) { resolve(); return; }

            const screenX = rect.left + window.pageXOffset + nextX;
            const screenY = rect.top + window.pageYOffset + nextY;
            for (const obstacle of obstacles) {
              const bounds = getObstacleBounds(obstacle);
              if (screenX >= bounds.left && screenX <= bounds.right && screenY >= bounds.top && screenY <= bounds.bottom) { resolve(); return; }
            }

            mainCtx.beginPath(); mainCtx.lineWidth = 10; mainCtx.moveTo(currentX, currentY);
            currentX = nextX; currentY = nextY;
            mainCtx.lineTo(currentX, currentY); mainCtx.stroke();

            // タートル位置更新
            const turtle = document.getElementById("turtle");
            const turtleWidth = turtle.offsetWidth; const turtleHeight = turtle.offsetHeight;
            turtle.style.left = `${rect.left + window.pageXOffset + currentX + x - turtleWidth / 2}px`;
            turtle.style.top = `${rect.top + window.pageYOffset + currentY - y - turtleHeight}px`;

            step--;

            // アニメーション終了時resolve呼び出し
            if (step === 0) { resolve(); }
            else {
              // ID保存、次フレーム予約（setTimeoutで速度一定化：10ms間隔）
              timeoutId = setTimeout(fd_draw, 10);
            }
          } else { resolve(); }
        }
        // 開始時ID保存
        timeoutId = setTimeout(fd_draw, 10);
      });
    }

    //////////////////
    ///// 右回転//////
    //////////////////
    function rt(angle) {
      return new Promise((resolve) => {
        a += angle;
        const turtle = document.getElementById("turtle");
        turtle.style.transform = `rotate(${a}deg)`;
        // CSSトランジション(0.5秒)待機
        timeoutId = setTimeout(resolve, 500);
      });
    }

    //////////////////
    ///// 左回転 //////
    //////////////////
    function lt(angle) {
      return new Promise((resolve) => {
        a -= angle;
        const turtle = document.getElementById("turtle");
        turtle.style.transform = `rotate(${a}deg)`;
        // CSSトランジション(0.5秒)待機
        timeoutId = setTimeout(resolve, 500);
      });
    }

    //////////////////
    /////スタート//////
    //////////////////
    async function start() {
      if (isRunning) return; // 二重起動防止
      isRunning = true;
      x = y = a = 0; turtle.style.transform = `rotate(${a}deg)`;
      for (var i = 0; i < codeAreaSize; i++) {
        if (!isRunning) break; // 停止フラグ確認
        i = await processCode(i);
      }
      isRunning = false;
      document.dispatchEvent(new CustomEvent("paintdone"));
    }

    function stopExecution() {
      isRunning = false; // 停止合図

      // アニメーションと待機時間をキャンセル
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      if (timeoutId) clearTimeout(timeoutId);

      // ブロックのハイライトを消す
      const highlightedBlocks = document.querySelectorAll('.block_highlights');
      highlightedBlocks.forEach(block => {
        block.classList.remove('block_highlights');
      });
    }

    async function processCode(index) {
      if (!isRunning) return index;
      if (!code_array[index] || code_array[index][0] === 0) return index;

      const blockElement = code_array[index][1];

      // ハイライト開始
      blockElement.classList.add("block_highlights");
      // ★追加：視認用ウェイト（これがないとハイライトが見えない）
      await new Promise(resolve => setTimeout(resolve, 50));

      console.log(`実行中のブロック：${code_array[index][0]} at index ${index}`);

      let nextIndex = index; // 次実行ブロックインデックス保持

      switch (code_array[index][0]) {
        case "fd": await fd(parseFloat(blockElement.querySelector("input").value)); break;
        case "rt": await rt(parseFloat(blockElement.querySelector("input").value)); break;
        case "lt": await lt(parseFloat(blockElement.querySelector("input").value)); break;
        case "for1":
          const end_for_index = code_array.findIndex((row, i) => row[0] === "for2" && i > index);
          if (end_for_index !== -1) {
            const repeatCount = parseFloat(blockElement.querySelector("input").value);

            const endBlockElement = code_array[end_for_index][1];
            endBlockElement.classList.add("block_highlights");

            for (let j = 0; j < repeatCount; j++) {
              if (!isRunning) break;
              for (let k = index + 1; k < end_for_index; k++) {
                if (!isRunning) break;
                k = await processCode(k);
              }
            }
            endBlockElement.classList.remove("block_highlights");//ループが終わったらハイライトを消す
            nextIndex = end_for_index; // 繰り返し終端へジャンプ
          } else { alert("繰り返しの終端が必要です。"); }
          break;
        case "if1":
          const end_if_index = code_array.findIndex((row, i) => row[0] === "if2" && i > index);
          if (end_if_index !== -1) {
            let hit = false;
            let rect = maincanvas.getBoundingClientRect();
            const nextX = currentX + turtle_speed * Math.sin((a * Math.PI) / 180.0);
            const nextY = currentY - turtle_speed * Math.cos((a * Math.PI) / 180.0);
            if (nextX <= 0 || nextX >= maincanvas.width || nextY <= 0 || nextY >= maincanvas.height) { hit = true; }
            const screenX = rect.left + window.pageXOffset + nextX;
            const screenY = rect.top + window.pageYOffset + nextY;
            for (const obstacle of obstacles) {
              const bounds = getObstacleBounds(obstacle);
              if (screenX >= bounds.left && screenX <= bounds.right && screenY >= bounds.top && screenY <= bounds.bottom) { hit = true; break; }
            }

            if (hit) {
              // IF真の場合、内部ブロック実行
              for (let k = index + 1; k < end_if_index; k++) {
                k = await processCode(k);
              }
            }
            nextIndex = end_if_index; // IF終端へジャンプ
          } else { alert("IFの終端が必要です。"); }
          break;
        case "for2":
        case "if2":
          // 終端ブロック処理なし
          break;
      }

      // ハイライト終了
      blockElement.classList.remove("block_highlights");

      return nextIndex; // 次インデックス返却
    }

    //////////////////
    ////一致判定/////
    //////////////////
    async function check() {
      try {
        const userCanvas = document.getElementById('mainCanvas');
        const correctImageElement = document.getElementById('overlayImage');

        const correctImage = new Image();
        correctImage.crossOrigin = "Anonymous";
        correctImage.src = correctImageElement.src;
        await new Promise((resolve, reject) => {
          correctImage.onload = resolve;
          correctImage.onerror = reject;
        });

        const userShape = getShapeData(userCanvas);
        const correctShape = getShapeData(correctImage);

        if (userShape.pixelCount === 0) {
          console.log("No drawing detected.");
          showAnswerMark(false);
          return;
        }

        const similarity = compareShapes(userShape, correctShape);

        console.log(`類似度スコア: ${similarity.toFixed(3)}`);

        //合格ライン（閾値）設定
        const urlParams = new URLSearchParams(window.location.search);
        const currentStage = urlParams.get("stage") || "1";
        let threshold = 0.70; // 基本の合格ライン70%
        if (currentStage === "4") {
          threshold = 0.50; // ステージ4だけ50%
          console.log("aaaaaaaaaa");
        }

        //類似度と閾値を比較
        const isCorrect = similarity >= threshold;

        //マークを表示
        showAnswerMark(isCorrect);

        //正解なら次へボタン表示
        if (isCorrect) {
          document.dispatchEvent(new CustomEvent("trianglecorrect"));
          const nextButton = document.getElementById("btn_next");
          if (nextButton) {
            nextButton.style.visibility = "visible";
          }
        }

      } catch (error) {
        console.error("error:", error);
        showAnswerMark(false);
      }
    }

    //絵の中から描かれた図形だけを切り抜く（白を背景、色部分を対象）
    function getShapeData(source) {
      // 作業用キャンバス作成
      const canvas = document.createElement('canvas');
      canvas.width = 700;
      canvas.height = 700;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });

      // 画像を描画
      ctx.drawImage(source, 0, 0, canvas.width, canvas.height);

      // 全ピクセルの色データ取得
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const binaryData = new Uint8Array(canvas.width * canvas.height);

      let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;
      let pixelCount = 0;

      // 全ピクセルを走査
      for (let i = 0; i < imageData.data.length; i += 4) {
        const r = imageData.data[i];
        const g = imageData.data[i + 1];
        const b = imageData.data[i + 2];
        const pixelIndex = i / 4;

        // 色がある部分（白以外）を検出
        if (r < 250 || g < 250 || b < 250) {
          binaryData[pixelIndex] = 1;
          pixelCount++;
          // 大きさの測定
          // 描画範囲（外枠）を更新
          const x = pixelIndex % canvas.width;
          const y = Math.floor(pixelIndex / canvas.width);
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        } else {
          binaryData[pixelIndex] = 0;
        }
      }

      // 図形が存在するか判定
      const boundingBox = (pixelCount > 20) ? { x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1 } : null;

      // 解析結果（データと位置情報）を返す
      return {
        binaryData: binaryData,
        width: canvas.width,
        height: canvas.height,
        boundingBox: boundingBox,
        pixelCount: pixelCount
      };
    }

    //2つの図形を重ねて類似度を採点
    function compareShapes(shapeA, shapeB) {
      // 描画有無の確認
      if (!shapeA.boundingBox || !shapeB.boundingBox) return 0;

      // 比較用の最大サイズ決定
      const comparisonWidth = Math.max(shapeA.boundingBox.width, shapeB.boundingBox.width);
      const comparisonHeight = Math.max(shapeA.boundingBox.height, shapeB.boundingBox.height);

      // 比較用キャンバス作成（A・B用）
      const canvasA = document.createElement('canvas');
      canvasA.width = comparisonWidth;
      canvasA.height = comparisonHeight;
      const ctxA = canvasA.getContext('2d');

      const canvasB = document.createElement('canvas');
      canvasB.width = comparisonWidth;
      canvasB.height = comparisonHeight;
      const ctxB = canvasB.getContext('2d');

      const tempImgDataA = ctxA.createImageData(shapeA.boundingBox.width, shapeA.boundingBox.height);
      const tempImgDataB = ctxB.createImageData(shapeB.boundingBox.width, shapeB.boundingBox.height);

      // 図形Aを切り出して中央配置
      for (let y = 0; y < shapeA.boundingBox.height; y++) {
        for (let x = 0; x < shapeA.boundingBox.width; x++) {
          const index = y * shapeA.boundingBox.width + x;
          const originalIndex = (shapeA.boundingBox.y + y) * shapeA.width + (shapeA.boundingBox.x + x);
          if (shapeA.binaryData[originalIndex] === 1) {
            tempImgDataA.data[index * 4 + 3] = 255;
          }
        }
      }
      // 図形Aを中央に配置
      ctxA.putImageData(tempImgDataA, (comparisonWidth - shapeA.boundingBox.width) / 2, (comparisonHeight - shapeA.boundingBox.height) / 2);

      // 図形Bを切り出して中央配置
      for (let y = 0; y < shapeB.boundingBox.height; y++) {
        for (let x = 0; x < shapeB.boundingBox.width; x++) {
          const index = y * shapeB.boundingBox.width + x;
          const originalIndex = (shapeB.boundingBox.y + y) * shapeB.width + (shapeB.boundingBox.x + x);
          if (shapeB.binaryData[originalIndex] === 1) {
            tempImgDataB.data[index * 4 + 3] = 255;
          }
        }
      }
      // 図形Bを中央に配置
      ctxB.putImageData(tempImgDataB, (comparisonWidth - shapeB.boundingBox.width) / 2, (comparisonHeight - shapeB.boundingBox.height) / 2);

      // 比較用画像データ取得
      const dataA = ctxA.getImageData(0, 0, comparisonWidth, comparisonHeight).data;
      const dataB = ctxB.getImageData(0, 0, comparisonWidth, comparisonHeight).data;

      let intersection = 0; // 重なり部分
      let union = 0;        // 全体の広さ

      // ピクセルごとの一致判定
      for (let i = 0; i < dataA.length; i += 4) {
        const pixelA = dataA[i + 3] > 0;
        const pixelB = dataB[i + 3] > 0;

        if (pixelA && pixelB) {
          intersection++;   // 両方ある（重なり）
        }
        if (pixelA || pixelB) {
          union++;          // どちらかある（全体）
        }
      }

      // 一致率を返す
      return union > 0 ? intersection / union : 0;
    }

    function next_stage() {
      const urlParams = new URLSearchParams(window.location.search);
      const currentStage = parseInt(urlParams.get("stage") || "1");
      if (currentStage >= 4) { window.location.href = "landing.html"; }
      else { const nextStage = currentStage + 1; window.location.href = `TurtleGraphics.html?stage=${nextStage}`; }
    }
    function return_menu() { window.location.href = "landing.html"; }
    function showAnswerMark(isCorrect) {
      const mark = document.getElementById("answer-mark");
      mark.textContent = isCorrect ? "〇" : "×";
      mark.style.color = isCorrect ? "green" : "red";
      mark.style.opacity = 1;
      setTimeout(() => { mark.style.opacity = 0; }, 1500);
    }


    //////////////////
    //チュートリアル///
    //////////////////
    let intro = introJs();
    let turtlePositionSet = false;
    let blockSet = false;
    let numSet = false;
    let paintdone = false;
    let chekdone = false;
    let trianglecorrect1 = false;
    let trianglecorrect2 = false;
    let trianglecorrect3 = false;
    let obstacleSet = false;

    //一時停止用の制御
    intro.onafterchange(function (targetElement) {
      const urlParams = new URLSearchParams(window.location.search);
      const stage = urlParams.get('stage') || '1';
      const currentStep = intro._currentStep;
      if (stage === '1') {
        //ユーザーがキャンバスをクリックするのを待つ
        if (currentStep === 3 && !turtlePositionSet) {
          intro.exit();
          const canvas = document.getElementById("canvas_wrapper");
          const handler = () => {
            turtlePositionSet = true;
            canvas.removeEventListener("click", handler);
            intro.goToStep(4);
          };

          canvas.addEventListener("click", handler);
        }
        //ユーザーがブロックを配置するのを待つ
        if (currentStep === 5 && !blockSet) {
          intro.exit();
          document.addEventListener('codeArrayChanged', function checkFdBlock() {
            if (code_array[0][0] === "fd") {
              blockSet = true;
              document.removeEventListener('codeArrayChanged', checkFdBlock);
              intro.goToStep(6);
            }
          });
        }
        //数値入力を待つ
        if (currentStep === 6 && !numSet) {
          intro.exit();
          const setupInputListener = () => {
            const numberInput = document.getElementById("number1");
            if (numberInput) {
              const inputHandler = function () {
                if (this.value === "300") {
                  numSet = true;
                  this.removeEventListener("input", inputHandler);
                  document.removeEventListener('codeArrayChanged', setupInputListener);
                  intro.goToStep(7);
                }
              };
              numberInput.addEventListener("input", inputHandler);
              return true;
            }
            return false;
          };
          const success = setupInputListener();
          if (!success) {
            document.addEventListener('codeArrayChanged', setupInputListener, { once: true });
          }
        }
        //ユーザーが描画完了するのを待つ
        if (currentStep === 7 && !paintdone) {
          intro.exit();
          document.addEventListener('paintdone', function checkpaintdone() {
            paintdone = true;
            document.removeEventListener('paintdone', checkpaintdone);
            intro.goToStep(8);
          }, { once: true });
        }
        //ユーザーのチェック完了を待つ
        if (currentStep === 8 && !chekdone) {
          intro.exit();
          const checkbtn = document.getElementById("btn_check");
          const handler = () => {
            chekdone = true;
            checkbtn.removeEventListener("click", handler);
            intro.goToStep(9);
          };

          checkbtn.addEventListener("click", handler, { once: true });
        }
      }
      else if (stage === '2') {
        if (currentStep === 5 && !trianglecorrect1) {
          intro.exit();
          //ユーザーが三角形を描画するのを待つ
          document.addEventListener('trianglecorrect', function checktrianglecorrect() {
            trianglecorrect1 = true;
            document.removeEventListener('trianglecorrect', checktrianglecorrect);
            intro.goToStep(6);
          }, { once: true });
        }
      }
      else if (stage === '3') {
        if (currentStep === 5 && !trianglecorrect2) {
          intro.exit();
          //ユーザーが三角形を描画するのを待つ
          document.addEventListener('trianglecorrect', function checktrianglecorrect() {
            trianglecorrect2 = true;
            document.removeEventListener('trianglecorrect', checktrianglecorrect);
            intro.goToStep(6);
          }, { once: true });
        }
      }
      else if (stage === '4') {
        if (currentStep === 5 && !obstacleSet) {
          intro.exit();
          // ユーザーが障害物を生成するのを待つ
          const generatebutton = document.getElementById("blockGenerateButton");
          const handler = () => {
            obstacleSet = true; // フラグを更新
            generatebutton.removeEventListener("click", handler); // イベントリスナーを削除
            intro.goToStep(6); // 次のステップに進む
          };
          generatebutton.addEventListener("click", handler); // イベントリスナーを追加
        }
        if (currentStep === 9 && !trianglecorrect3) {
          intro.exit();
          //ユーザーが三角形を描画するのを待つ
          document.addEventListener('trianglecorrect', function checktrianglecorrect() {
            trianglecorrect3 = true;
            document.removeEventListener('trianglecorrect', checktrianglecorrect);
            intro.goToStep(10).start();
          }, { once: true });
        }
      }
    });
  </script>
</body>

</html>