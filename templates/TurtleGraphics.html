<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utfr-8" />
    <title>Turtle Graphics</title>
    <link type="text/css" rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/cupertino/jquery-ui.min.css" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/TurtleGraphics.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/introjs.min.css') }}">
</head>

<body>
    <div id="page" style="width: 100%; height: 100%">
        <div id="main">
            <div id="canvas_area">
                <div id="taskname">{{ title }}</div>
                <div id="canvas_wrapper">
                    <div id="answer-mark" class="mark-icon">〇</div>
                    <div data-step='1' data-intro='Help Text First!!'>
                        <canvas id="mainCanvas" width="700" height="700"></canvas>
                    </div>
                    <canvas id="gridCanvas" width="700" height="700"></canvas>
                    <img id="overlayImage" src="static/assets/{{ image }}" />
                </div>
                <div id="field">
                    <div class="color-picker-container">
                        <label class="color-picker-label" for="colorPicker">Color Picker:</label>
                        <input class="color-picker" type="color" id="colorPicker" value="#000000" />
                    </div>
                    {{ generate_html|safe }}
                    <button class="btn" type="button" id="checkButton" onclick="grid()">
                        GridONOFF
                    </button>
                    <button id="btn_check" class="btn btn_check" type="button" id="checkButton" onclick="check()">
                        CHECK
                    </button>
                </div>
            </div>

            <div id="center_area">
                <div>
                    <button id="btn_start" class="btn btn_start" type="button" onclick="start()">
                        START
                    </button>
                    <button class="btn btn_start" type="button" onclick="clearbtn()">
                        CLEAR
                    </button>
                </div>

                <div id="code_area">
                    <div id="code_area1" class="blocksnap_area"></div>
                    <div id="code_area2" class="blocksnap_area"></div>
                    <div id="code_area3" class="blocksnap_area"></div>
                    <div id="code_area4" class="blocksnap_area"></div>
                    <div id="code_area5" class="blocksnap_area"></div>
                    <div id="code_area6" class="blocksnap_area"></div>
                    <div id="code_area7" class="blocksnap_area"></div>
                    <div id="code_area8" class="blocksnap_area"></div>
                    <div id="code_area9" class="blocksnap_area"></div>
                </div>
            </div>

            <div id="block_area">
                {{ blocks_html|safe }}
            </div>
            <div id="others_area">
                <div id="help">

                    <!-- <button class="btn btn_help" type="button" onclick="help()">Help</button> -->
                    <button id="btn_menu" class="btn_menu" type="button" onclick="return_menu()">menu</button>
                    <button id="btn_next" class="btn_next" type="button" onclick="next_stage()">next</button>

                </div>
            </div>
        </div>
    </div>

    <img src="static/assets/turtle.png" id="turtle" style="position: absolute; top: 450px; left: 450px" />
    <script src="{{ url_for('static', filename='js/intro.min.js') }}"></script>
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/ui/1.10.3/jquery-ui.min.js"></script>
    <script type="text/javascript">
        var startx = 450; //初期位置
        var starty = 450; //初期位置
        canvrate_x = 900 / window.innerWidth;
        canvrate_y = 900 / window.innerHeight;
        let currentX = startx;
        let currentY = starty;
        turtle_speed = 1;
        codeAreaSize = 9;
        tutorialCheck1 = false;


        //////////////////
        ////キャンバス/////
        //////////////////
        const maincanvas = document.querySelector("#mainCanvas");
        const gridcanvas = document.querySelector("#gridCanvas");
        const cvs = document.getElementById("mainCanvas");
        let rect = cvs.getBoundingClientRect(); // 初期値を設定
        const colorPicker = document.getElementById("colorPicker");
        const mainCtx = maincanvas.getContext("2d");
        const gridCtx = gridcanvas.getContext("2d");
        var x = (y = a = 0);
        // 初期の線の色
        let lineColor = "rgb(0, 0, 0)";

        mainCtx.fillStyle = "rgb(256, 256, 256)"; // キャンバスの背景色（内側の白色） 
        mainCtx.fillRect(0, 0, maincanvas.width, maincanvas.height);

        // グリッド描画
        const gridSize = 100;  // グリッド間隔（100ピクセル）
        gridCtx.strokeStyle = "rgb(200, 200, 200)";
        gridCtx.lineWidth = 1;
        for (let i = gridSize; i < Math.max(gridcanvas.width, gridcanvas.height); i += gridSize) {
            if (i < gridcanvas.width) {
                gridCtx.beginPath();
                gridCtx.moveTo(i, 0);
                gridCtx.lineTo(i, gridcanvas.height);
                gridCtx.stroke();
            }
            if (i < gridcanvas.height) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, i);
                gridCtx.lineTo(gridcanvas.width, i);
                gridCtx.stroke();
            }
        }

        mainCtx.strokeStyle = lineColor;

        // イベントリスナーを追加して色の変更を検知する
        colorPicker.addEventListener("input", function () {
            lineColor = colorPicker.value;
            mainCtx.strokeStyle = lineColor;
        });

        cvs.addEventListener("click", e => {
            rect = e.target.getBoundingClientRect();

            // ブラウザ上でのクリック位置を取得
            const viewX = e.clientX - rect.left,
                viewY = e.clientY - rect.top;

            // 表示サイズとキャンバスの実際のサイズ比率を計算
            const scaleWidth = cvs.clientWidth / cvs.width,
                scaleHeight = cvs.clientHeight / cvs.height;

            // ブラウザのクリック位置をキャンバス上の位置に変換
            const canvasX = Math.floor(viewX / scaleWidth),
                canvasY = Math.floor(viewY / scaleHeight);

            currentX = canvasX;
            currentY = canvasY;
            // タートル要素を取得
            const turtle = document.getElementById("turtle");

            // タートルの幅と高さを取得
            const turtleWidth = turtle.offsetWidth; // 26px
            const turtleHeight = turtle.offsetHeight; // 36px

            // カメのしっぽの位置をクリック位置に合わせるための調整
            // しっぽが画像の中央下部であるため、x座標は中央、y座標は下部に合わせる
            turtle.style.position = "absolute";
            turtle.style.left = `${rect.left + window.pageXOffset + canvasX - turtleWidth / 2}px`;
            turtle.style.top = `${rect.top + window.pageYOffset + canvasY - turtleHeight}px`;

        });

        // ページ読み込み時にクエリパラメータからステージの値を取得して処理
        window.addEventListener('DOMContentLoaded', function () {
            const urlParams = new URLSearchParams(window.location.search);
            const stage = urlParams.get('stage') || '1';
            const stageValueElement = document.getElementById('stageValue');
            if (stageValueElement) {
                stageValueElement.textContent = stage;
            }
        });

        const obstacles = []; // 障害物を格納する配列を初期化

        let imageCounter = 0;
        function block_Generate() {
            const canvasWrapper = document.getElementById('canvas_wrapper');
            const canvas = document.getElementById('mainCanvas');
            const img = document.createElement('img');
            img.src = 'static/assets/Obstacle.png';
            img.classList.add('draggable');

            // 画像サイズ
            img.width = 50;
            img.height = 50;

            // キャンバス内の座標系に合わせて配置
            const gridSize = 50;
            const cols = Math.floor(canvas.width / gridSize);
            const x = (imageCounter % cols) * gridSize;
            const y = Math.floor(imageCounter / cols) * gridSize;

            img.style.position = 'absolute';
            img.style.left = `${canvas.offsetLeft + x}px`;
            img.style.top = `${canvas.offsetTop + y}px`;

            canvasWrapper.appendChild(img);
            imageCounter++;

            obstacles.push(img); // 配列に障害物を追加

            $(img).draggable({
                containment: '#canvas_wrapper'
            });
        }

        //////////////////
        //ドラッグ処理//
        //////////////////
        $(function () {
            var now_object = null;

            $(".block").draggable({
                // ドラッグ開始時の処理
                start: function () {
                    now_object = $(this);
                    now_object.addClass("block_drag");
                    now_object.removeClass("block_snap");
                },
                //ドラッグ終了時の処理
                stop: function () {
                    now_object.removeClass("block_drag");
                    //配列を作る
                    create_array();
                },
            });

            $(".blocksnap_area").droppable({
                hoverClass: "block_hover",
                //ドロップした時
                drop: function (event, ui) {
                    now_object.offset({
                        top: $(this).offset().top,
                        left: $(this).offset().left - 3,
                    });
                    now_object.addClass("block_snap");
                },
            });
        });

        //////////////////
        // 配列を作る ////
        //////////////////
        var code_array = [];
        for (var i = 0; i < codeAreaSize; i++) {
            code_array[i] = [];
            for (var j = 0; j < 2; j++) {
                code_array[i][j] = 0;
            }
        }

        const totalBlocks = parseInt("{{ total_blocks }}");
        let element = null;
        let datatype = null;

        function create_array() {
            // 各コードエリアとブロックの位置を取得
            const codearea_top = Array.from({ length: 9 }, (_, i) => $(`#code_area${i + 1}`).offset().top);
            const codearea_left = Array.from({ length: 9 }, (_, i) => $(`#code_area${i + 1}`).offset().left);
            const blocks_top = Array.from({ length: totalBlocks }, (_, i) => $(`#block${i + 1}`).offset().top);
            const blocks_left = Array.from({ length: totalBlocks }, (_, i) => $(`#block${i + 1}`).offset().left);

            const size = totalBlocks; // 配列の大きさ
            let array_flag = 0;

            // 上のエリアから順に何のブロックがドロップされているか検知
            // ブロック1からブロック9まで(1,2,3,4,5,6,7,8,9)を配列に代入
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (
                        codearea_top[i] === blocks_top[j] &&
                        codearea_left[i] === blocks_left[j] + 3
                    ) {
                        element = document.getElementById(`block${j + 1}`);
                        code_array[i][0] = element.dataset.type;
                        code_array[i][1] = document.getElementById(`block${j + 1}`);
                        array_flag = 1;
                        break; // マッチしたら内側のループを抜ける
                    }
                }
                // ブロックを検知できなかった時、0を入れる
                if (array_flag === 0) {
                    code_array[i][0] = 0;
                } else {
                    array_flag = 0;
                }
            }
            console.log("配列＝" + code_array);
            const event = new CustomEvent('codeArrayChanged');
            document.dispatchEvent(event);
        }

        let flag = false;
        function grid() {
            // グリッド描画
            const gridSize = 100;  // グリッド間隔（100ピクセル）
            gridCtx.strokeStyle = "rgb(200, 200, 200)";
            gridCtx.lineWidth = 1;

            if (flag == true) {
                mainCtx.strokeStyle = "rgb(255, 255, 255)";
                for (let i = gridSize; i < Math.max(gridcanvas.width, gridcanvas.height); i += gridSize) {
                    if (i < gridcanvas.width) {
                        gridCtx.beginPath();
                        gridCtx.moveTo(i, 0);
                        gridCtx.lineTo(i, gridcanvas.height);
                        gridCtx.stroke();
                    }
                    if (i < gridcanvas.height) {
                        gridCtx.beginPath();
                        gridCtx.moveTo(0, i);
                        gridCtx.lineTo(gridcanvas.width, i);
                        gridCtx.stroke();
                    }
                }
                flag = false;
            }
            else {
                gridCtx.clearRect(0, 0, gridcanvas.width, gridcanvas.height);
                flag = true;
            }
        }

        //////////////////
        ///// クリア //////
        //////////////////
        function clearbtn() {
            mainCtx.fillRect(0, 0, maincanvas.width, maincanvas.height);
        }
        function getObstacleBounds(obstacle) {
            const rect = obstacle.getBoundingClientRect();
            return {
                left: rect.left,
                right: rect.right,
                top: rect.top,
                bottom: rect.bottom
            };
        }
        //////////////////
        ///// 前進 //////
        //////////////////
        function fd(step) {
            return new Promise((resolve) => {
                function fd_draw() {
                    lineColor = colorPicker.value;
                    mainCtx.strokeStyle = lineColor;
                    if (step > 0) {
                        const nextX = currentX + turtle_speed * Math.sin((a * Math.PI) / 180.0);
                        const nextY = currentY - turtle_speed * Math.cos((a * Math.PI) / 180.0);

                        // 画面端との衝突判定
                        if (nextX <= 0 || nextX >= maincanvas.width || nextY <= 0 || nextY >= maincanvas.height) {
                            resolve();
                            return;
                        }

                        // 障害物との衝突判定
                        const screenX = rect.left + window.pageXOffset + nextX;
                        const screenY = rect.top + window.pageYOffset + nextY;

                        for (const obstacle of obstacles) {
                            const bounds = getObstacleBounds(obstacle);
                            if (
                                screenX >= bounds.left &&
                                screenX <= bounds.right &&
                                screenY >= bounds.top &&
                                screenY <= bounds.bottom
                            ) {
                                resolve(); // 衝突した
                                return;
                            }
                        }


                        mainCtx.beginPath();
                        mainCtx.lineWidth = 10;
                        mainCtx.moveTo(currentX, currentY);
                        currentX = nextX;
                        currentY = nextY;
                        mainCtx.lineTo(currentX, currentY);
                        mainCtx.stroke();

                        const turtleWidth = turtle.offsetWidth;
                        const turtleHeight = turtle.offsetHeight;
                        turtle.style.left = `${rect.left + window.pageXOffset + currentX + x - turtleWidth / 2}px`;
                        turtle.style.top = `${rect.top + window.pageYOffset + currentY - y - turtleHeight}px`;
                        step--;

                        if (step === 0) {
                            resolve();
                        } else {
                            requestAnimationFrame(fd_draw);
                        }
                    }
                }
                fd_draw();
            });
        }


        // 右回転
        function rt(angle) {
            a += angle;
            // タートルの回転角度を更新
            turtle.style.transform = `rotate(${a}deg)`;
        }

        // 左回転
        function lt(angle) {
            a -= angle;
            // タートルの回転角度を更新
            turtle.style.transform = `rotate(${a}deg)`;
        }

        //////////////////
        /////スタート//////
        //////////////////

        async function start() {
            x = y = a = 0;
            a = 0;
            abortFlag = false;
            turtle.style.transform = `rotate(${a}deg)`;

            const end_if_index = code_array.findIndex(row => row[0] === "if2");
            const start_if_index = code_array.findIndex(row => row[0] === "if1");

            // if1 が存在する場合のみチェック
            if (start_if_index !== -1) {
                if (end_if_index !== -1) {
                    if (end_if_index < start_if_index) {
                        alert("順番がおかしい");
                        return; // 不正な順番なら処理終了
                    }
                } else {
                    alert("IFの終端が必要");
                    return; // IF2がない場合も処理終了
                }
            }
            // 全体ループ処理（if2の順番が正しい場合のみ実行）
            for (var i = 0; i < totalBlocks; i++) {
                i = await processCode(i);
                if (abortFlag) {
                    console.log("start() 処理中断！");
                    break;
                }
            }
            const event = new CustomEvent('paintdone');
            document.dispatchEvent(event);
        }

        async function processCode(index) {
            console.log(`実行中のブロック：${code_array[index][0]} at index ${index}`); // デバッグメッセージ
            switch (code_array[index][0]) {
                case "fd":
                    await fd(parseFloat(code_array[index][1].querySelector("input").value));
                    break;
                case "rt":
                    rt(parseFloat(code_array[index][1].querySelector("input").value));
                    break;
                case "lt":
                    lt(parseFloat(code_array[index][1].querySelector("input").value));
                    break;
                case "for1":
                    //code_arrayにfor2が含まれているか
                    const end_for_index = code_array.findIndex(row => row[0] === "for2");
                    if (end_for_index !== -1) {
                        const start_for = index;

                        if (end_for_index < start_for) {
                            alert("順番がおかしい");
                            break;
                        }

                        const inputvalue = code_array[start_for][1].querySelector("input");
                        const repeatCount = parseFloat(inputvalue.value);

                        for (let j = 1; j <= repeatCount; j++) {
                            for (let k = start_for + 1; k < end_for_index; k++) {
                                k = await processCode(k);
                            }
                        }
                        return end_for_index; // for2の次のインデックスにジャンプ
                    } else {
                        alert("繰り返しの終端が必要");
                    }
                    break;
                case "if1":
                    const end_if_index = code_array.findIndex((row, i) => row[0] === "if2" && i > index);
                    const start_if = index;

                    const nextX = currentX + turtle_speed * Math.sin((a * Math.PI) / 180.0);
                    const nextY = currentY - turtle_speed * Math.cos((a * Math.PI) / 180.0);

                    const screenX = rect.left + window.pageXOffset + nextX;
                    const screenY = rect.top + window.pageYOffset + nextY;

                    // 衝突フラグ（端 or 障害物）
                    let hit = false;

                    // 端との衝突
                    if (nextX <= 0 || nextX >= maincanvas.width || nextY <= 0 || nextY >= maincanvas.height) {
                        hit = true;
                        console.log("カメがキャンバスの端に到達しました");
                    }

                    // 障害物との衝突
                    for (const obstacle of obstacles) {
                        const bounds = getObstacleBounds(obstacle);
                        if (
                            screenX >= bounds.left &&
                            screenX <= bounds.right &&
                            screenY >= bounds.top &&
                            screenY <= bounds.bottom
                        ) {
                            hit = true;
                            console.log("カメが障害物にぶつかりました");
                            break;
                        }
                    }

                    // 衝突していたら if ブロック実行
                    if (hit) {
                        for (let k = start_if + 1; k < end_if_index; k++) {
                            k = await processCode(k);
                        }
                    }

                    return end_if_index;

                    break;
                case 11:
                    break; // 終端
                default:
                    break;
            }
            return index; // 次のインデックスに進む
        }

        //////////////////////////////////////////////////
        ////////////pythonデータ受け渡し///////////////////
        //////////////////////////////////////////////////
        function check() {
            const imageData = mainCtx.getImageData(
                10,
                10,
                maincanvas.width - 20,
                maincanvas.height - 20
            );
            // Canvasを作成し、取得した画像データを描画
            const tempCanvas = document.createElement('canvas');
            const tempmainCtx = tempCanvas.getContext('2d');
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            tempmainCtx.putImageData(imageData, 0, 0);
            // ImageDataをBase64に変換
            const base64Image = tempCanvas.toDataURL("image/png");
            const urlParams = new URLSearchParams(window.location.search);
            const stage = urlParams.get('stage') || '1';

            // 送信するデータをオブジェクトにまとめる
            const sendData = {
                imgnumData: stage,
                imageData: base64Image
            };

            console.log("Sending stage:", stage);
            console.log("ImageData length:", base64Image.length);

            fetch("/match_images", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(sendData)
            })
                .then(response => response.json())
                .then(data => {
                    const isCorrect = data.matchingValue >= 0.2;
                    showAnswerMark(isCorrect);

                    if (isCorrect) {
                        const event = new CustomEvent('trianglecorrect');
                        document.dispatchEvent(event);

                        const nextButton = document.getElementById("btn_next");
                        if (nextButton) {
                            nextButton.style.visibility = "visible";
                        }
                    }
                })
                .catch(error => {
                    console.error("Error:", error);
                    showAnswerMark(false);
                });
        }

        function next_stage() {
            const urlParams = new URLSearchParams(window.location.search);
            const currentStage = parseInt(urlParams.get("stage") || "1");
            const nextStage = currentStage + 1;
            window.location.href = `/TurtleGraphics?stage=${nextStage}`;
        }

        function return_menu() {
            window.location.href = '/';
        }

        let intro = introJs();
        let turtlePositionSet = false;
        let blockSet = false;
        let numSet = false;
        let paintdone = false;
        let chekdone = false;
        let trianglecorrect1 = false;
        let trianglecorrect2 = false;

        //一時停止用の制御
        intro.onafterchange(function (targetElement) {
            const urlParams = new URLSearchParams(window.location.search);
            const stage = urlParams.get('stage') || '1';
            const currentStep = intro._currentStep;
            if (stage === '1') {
                if (currentStep === 9 && !turtlePositionSet) {
                    intro.exit();

                    //ユーザーがキャンバスをクリックするのを待つ
                    const canvas = document.getElementById("canvas_wrapper");
                    const handler = () => {
                        turtlePositionSet = true;
                        canvas.removeEventListener("click", handler);
                        intro.goToStep(10);
                    };

                    canvas.addEventListener("click", handler);
                }
                if (currentStep === 11 && !blockSet) {
                    intro.exit();

                    //ユーザーがブロックを配置するのを待つ
                    document.addEventListener('codeArrayChanged', function checkFdBlock() {
                        if (code_array[0][0] === "fd") {
                            blockSet = true;
                            document.removeEventListener('codeArrayChanged', checkFdBlock);
                            intro.goToStep(12);
                        }
                    });
                }
                if (currentStep === 12 && !numSet) {
                    intro.exit();
                    const numberInput = document.getElementById("number1");

                    // ユーザーの数値入力を待つ
                    const inputHandler = function () {
                        if (numberInput.value === "300") {
                            numSet = true;
                            numberInput.removeEventListener("input", inputHandler);
                            intro.goToStep(13);
                        }
                    };

                    // 入力フィールドの変更を監視
                    numberInput.addEventListener("input", inputHandler);
                }
                if (currentStep === 14 && !paintdone) {
                    intro.exit();
                    //ユーザーが描画完了するのを待つ
                    document.addEventListener('paintdone', function checkpaintdone() {
                        paintdone = true;
                        document.removeEventListener('paintdone', checkpaintdone);
                        intro.goToStep(15);
                    });
                }
                if (currentStep === 16 && !chekdone) {
                    intro.exit();
                    //ユーザーがチェック完了を待つ
                    const checkbtn = document.getElementById("btn_check");
                    const handler = () => {
                        chekdone = true;
                        checkbtn.removeEventListener("click", handler);
                        intro.goToStep(17);
                    };

                    checkbtn.addEventListener("click", handler);
                }
            }
            else if (stage === '2') {
                if (currentStep === 5 && !trianglecorrect1) {
                    intro.exit();
                    //ユーザーが三角形を描画するのを待つ
                    document.addEventListener('trianglecorrect', function checktrianglecorrect() {
                        trianglecorrect1 = true;
                        document.removeEventListener('trianglecorrect', checktrianglecorrect);
                        intro.goToStep(6).start();
                    });
                }
            }
            else if (stage === '3') {
                if (currentStep === 5 && !trianglecorrect2) {
                    intro.exit();
                    //ユーザーが三角形を描画するのを待つ
                    document.addEventListener('trianglecorrect', function checktrianglecorrect() {
                        trianglecorrect2 = true;
                        document.removeEventListener('trianglecorrect', checktrianglecorrect);
                        intro.goToStep(6).start();
                    });
                }
            }
        });

        window.addEventListener("DOMContentLoaded", () => {
            const urlParams = new URLSearchParams(window.location.search);
            const stage = urlParams.get('stage') || '1';
            fetch(`/static/json/tutorials_stage${stage}.json`)
                .then(res => res.json())
                .then(steps => {
                    intro.setOptions({ steps });
                    intro.setOptions({
                        showProgress: false,
                        disableInteraction: true,
                        exitOnEsc: false,
                        exitOnOverlayClick: false,
                        nextLabel: "次へ",
                        prevLabel: "戻る",
                        doneLabel: "完了",
                        steps: steps
                    });
                    intro.start();
                });
        });


        function showAnswerMark(isCorrect) {
            const mark = document.getElementById("answer-mark");
            mark.textContent = isCorrect ? "〇" : "×";
            mark.style.color = isCorrect ? "green" : "red";
            mark.style.opacity = 1;

            setTimeout(() => {
                mark.style.opacity = 0;
            }, 1500);
        }

    </script>
</body>

</html>